norm_cfg = dict(type='BN', requires_grad=True)  # 单GPU使用BN
data_preprocessor = dict(  # 数据预处理配置
    type='SegDataPreProcessor',  # 数据预处理类型
    # mean=[123.675, 116.28, 103.53],  # 用于归一化输入的均值
    # std=[58.395, 57.12, 57.375],  # 用于归一化输入的标准差
    mean=[0.485, 0.456, 0.406],  # 用于归一化输入的均值
    std=[0.229, 0.224, 0.225],  # 用于归一化输入的标准差
    bgr_to_rgb=True,  # 是否将图像从BGR转为RGB
    pad_val=0,  # 图像的填充值
    seg_pad_val=255)  # gt_seg_map的填充值
model = dict(  # 模型配置
    type='EncoderDecoder',  # 使用编码器-解码器分割器结构
    data_preprocessor=data_preprocessor,  # 数据预处理器
    pretrained=None,  # 预训练模型
    backbone=dict(  # 编码器/主干网络配置
        type='MiTDePatchGlobal',  # 编码器/主干网络类型
        in_channels=3,  # 输入通道数
        embed_dims=32,  # embed维度（乘以特征维度的缩放倍数即等于每一个TR Block输出的特征维度）
        num_stages=4,  # 阶段数量（等于TR Block的数量）
        num_layers=[2, 2, 2, 2],  # 每个TR Block中Transformer编码层的数量
        num_heads=[1, 2, 5, 8],  # 每个TR Block的特征维度缩放倍数
        patch_sizes=[7, 3, 3, 3],  # 每个Overlapped Patch Embed层的patch大小
        strides=[4, 2, 2, 2],  # 每个Overlapped Patch Embed层的patch步幅
        sr_ratios=[8, 4, 2, 1],  # 每个Transformer编码层的空间缩减率
        out_indices=(0, 1, 2, 3),  # 输出的阶段索引
        mlp_ratio=4,  # MLP隐藏层维度与嵌入维度的比例
        qkv_bias=True,  # 如果为True，则启用qkv的偏置
        drop_rate=0.0,  # 元素被置零的概率
        attn_drop_rate=0.0,  # 注意力层丢失率
        drop_path_rate=0.1),  # 随机深度率
    decode_head=dict(  # 解码器参数配置
        type='MLPHeadGlobal',  # 解码器类型
        in_channels=[32, 64, 160, 256],  # 输入特征图的通道数
        in_index=[0, 1, 2, 3],  # 输入特征图的索引
        channels=256,  # 中间层的特征图通道数
        dropout_ratio=0.1,  # 进入最后分类层前的dropout比例
        num_classes=19,  # 输出类别数
        norm_cfg=norm_cfg,  # 归一化配置
        align_corners=False,  # 是否对角线对齐像素点
        loss_decode=dict(  # 解码器的损失函数配置
            type='CrossEntropyLoss',  # 损失函数类型
            use_sigmoid=False,  # 是否使用Sigmoid激活函数
            loss_weight=1.0)),  # 损失函数权重
    train_cfg=dict(),  # 训练配置，当前仅是一个占位符
    test_cfg=dict(mode='whole'))  # 测试配置，whole为全卷积测试，slide为滑窗测试
